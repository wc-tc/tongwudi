练习
1.1 假设有一个包含128个名字的有序列表，你要使用二分查找在其中查找一个名字，请
问最多需要几步才能找到？
log 128 =64=32=16=8=4=2=1;
2X2X2X2X2X2X2
7次
1.2 上面列表的长度翻倍后，最多需要几步？
8次

log M  M个有序的数组 需要要的次数为  2的N次方=M


 O(log n)，也叫对数时间，这样的算法包括二分查找。
 O(n)，也叫线性时间，这样的算法包括简单查找。
 O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
 O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

上述这个时间其实就是次数

使用大O表示法给出下述各种情形的运行时间。
1.3 在电话簿中根据名字查找电话号码。
O(log n)
1.4 在电话簿中根据电话号码找人。（提示：你必须查找整个电话簿。）
O(n)
1.5 阅读电话簿中每个人的电话号码。
O(n)
1.6 阅读电话簿中姓名以A打头的人的电话号码。这个问题比较棘手，它涉及第4章的概
念。答案可能让你感到惊讶！
0(n)

小结
 二分查找的速度比简单查找快得多。
 O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
 算法运行时间并不以秒为单位。
 算法运行时间是从其增速的角度度量的。
 算法运行时间用大O表示法表示。

小结
数组和链表算法速度
     数组    链表
读取  O(1)   O(n)
插入  O(n)   O(1)
删除  O(n)   O(1)


第二章选择排序小练习
2.2 链表
2.3 数组
2.4 每次插入数组 插入的数右边都会迁移 如果连续长度不够就都会迁移  速度为O(1)
2.5 查找时候比数组慢  插入的时候和链表相当少一次


第三章递归
两个条件
基数条件 决定递归的终止
递归条件 决定递归的进行
3.2 假设你编写了一个递归函数，但不小心导致它没完没了地运行。正如你看到的，对于
每次函数调用，计算机都将为其在栈中分配内存。递归函数没完没了地运行时，将给
栈带来什么影响？
会导致栈内存不够出现OOM栈内存溢出

第四章
快速排序
核心理论

分而治之
(1) 找出简单的基线条件;
(2) 确定如何缩小问题的规模，使其符合基线条件;

使用大O表示法时，下面各种操作都需要多长时间？
4.5 打印数组中每个元素的值。
On
4.6 将数组中每个元素的值都乘以2。
On
4.7 只将数组中第一个元素的值乘以2
O1
4.8 根据数组包含的元素创建一个乘法表，即如果数组为[2, 3, 7, 8, 10]，首先将每个元素
都乘以2，再将每个元素都乘以3，然后将每个元素都乘以7，以此类推
On平方
